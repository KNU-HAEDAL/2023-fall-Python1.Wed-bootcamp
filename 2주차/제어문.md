# 제어문

파이썬은 기본적으로 **‘먼저 나타나는 코드가 먼저 실행되는’** 순차적 실행 구조를 갖고 있고, 이처럼 순차적으로 진행되는 문장을 **‘순차문(sequential statement)’**이라고 합니다.

```python
#예시(순차문)
num = 100
print('num =', num)
num = num + 100
print('num =', num)
num = num + 100
print('num =', num)

#수행 결과
num = 100
num = 200
num = 300 #num의 값이 순차적으로 100씩 더해져 출력되는 것을 확인 가능
```

그러나 프로그램에서는 항상 순차적인 흐름만 존재하는 것이 아니고, 특정 조건이 만족되어야만 해당 명령어가 수행되거나, 조건에 따라 서로 다른 일을 해야 할 때도 있습니다.

⇒ 이렇게 **프로그램의 흐름을 제어하는 명령문**을 **‘제어문(control statement)’**이라고 하며, 크게 조건문과 반복문으로 구분됩니다.

## 조건문(conditional statement)

### 1. **if 조건문**

조건식에 따라 수행하는 내용이 달라지는 문장입니다.

기본 형식은

`if (조건식) :`

`(조건식이 참일 때 수행되는 문장)`

이며, 조건을 만족했을 때 실행되는 특정 코드의 덩어리를 **‘블록(block)’**이라고 합니다.

새롭게 나타나는 블록은 현재의 들여쓰기보다 더 깊이 들여서 써야 합니다.

동일한 블록에서는 들여쓰기의 정도(칸 수)가 일치해야 합니다.

```python
#예시
a = 3
b = 5
if a < b:
	print('b가 a보다 큽니다.')

#수행 결과
b가 a보다 큽니다.

#예시
a = 3
b = 5
if a < b:
print('b가 a보다 큽니다.')

#수행 결과
File "c:\Users\팡철\Desktop\코딩\hello world.py", line 4
    print('b가 a보다 큽니다.')
    ^
IndentationError: expected an indented block after 'if' statement on line 3
```

위 예시의 경우 조건식이 a<b 이고, 해당 연산의 반환값이 True 이므로 print 문장을 수행한 것입니다!

들여쓰기를 하지 않으면 오류가 발생하는 것도 확인할 수 있습니다.

만약 해당 예시에서 조건식의 반환값이 False이면 어떻게 될까요?

```python
#예시
a = 3
b = 5
if a > b:
	print('a가 b보다 큽니다.')

#수행 결과

```

조건을 만족하지 않는 경우, 아무런 동작도 하지 않음을 확인할 수 있습니다.

이런 경우에도 특정 동작을 수행하고 싶을 땐 어떻게 해야 할까요?

### 2. **if-else 조건문**

기본 형식은 아래와 같습니다.

`if (조건식) :`

`(조건식이 참일 때 수행되는 문장)`

`else :`

`(조건식이 참이 아닐 때 수행되는 문장)`

조건식의 반환값이 True이면 if의 하위 블록에 해당하는 문장을, False이면 else의 하위 블록에 해당하는 문장을 수행합니다.

```python
#예시
hour = 21

if hour < 12:
	print('오전입니다')
else:
	print('오후입니다')

#수행 결과
오후입니다
```

조건식 hour<12의 반환값이 False이므로, if의 하위 블록을 실행하지 않고 else의 하위 블록을 실행함을 확인할 수 있습니다.

if-else문은 조건이 두 가지로 나뉘고, 상호배타적일 때 사용하기 좋은 제어문입니다.

조건이 여러가지일 때도 단순 if문이나 if-else문을 여러 개 사용해서 구현 가능하지만, 계산 효율이 좋지 않거나 블록이 너무 많아져 가독성이 떨어진다는 단점이 있습니다.

이런 경우에 쓰기 좋은 구문이 있을까요?

### 3. **if-elif-else 조건문**

기본 형식은 아래와 같습니다.

`if (조건식1) :`

`(조건식1이 참일 때 수행되는 문장)`

`elif (조건식2) :`

`(조건식1이 참이 아니고 조건식2가 참일 때 수행되는 문장)`

`elif (조건식3) :`

`(조건식1과 2가 참이 아니고 조건식3이 참일 때 수행되는 문장)`

`…`

`else :`

`(조건식1, 조건식2, … , 조건식n이 모두 참이 아닐 때 수행되는 문장)`

```python
#예시
score = int(input('점수를 입력하세요 : '))

if score >= 90: #점수가 90점 이상인 경우 A
	grade = 'A'
elif score >= 80: #A가 아닌 경우, 80점 이상이면 B
	grade = 'B'
elif score >= 70: #B도 아닌 경우, 70점 이상이면 C
	grade = 'C'
elif score >= 60: #C도 아닌 경우, 60점 이상이면 D
	grade = 'D'
else: #그 외의 경우(60점 미만) F
	grade = 'F'

print('당신의 등급은 :', grade)

#수행 결과
점수를 입력하세요 : 88
당신의 등급은 : B
```

이처럼 if-elif-else 구문은 다중 조건을 처리할 때에 아주 유용하게 쓰인답니다!

if문에서 조건식은 어떻게 작성될까요?

-   다양한 연산자의 사용이 가능합니다.

    ```python
    #예시1
    if a > b:
    	print('a가 b보다 큽니다.')

    #예시2
    if a % 2 == 0:
    	print('a는 짝수입니다.')

    #예시3
    if (a % 2 == 0) and (b % 2 == 0):
    	print('a와 b 모두 짝수입니다.')

    #예시4
    if (a % 2 == 0) or (b % 2 == 0):
    	print('적어도 하나 이상이 짝수입니다.')
    ```

-   list, tuple, 문자열 등이 사용될 수 있습니다.
    A in list 구문은 해당 list 내부에 A라는 요소가 포함되어 있을 때 True를 반환합니다.

    ```python
    #예시1
    a = 3
    num=[1, 2, 3, 4]
    if a in num:
    	print('a는 num의 요소로 존재합니다.')

    #수행 결과
    a는 num의 요소로 존재합니다.

    #예시2
    a = 'r'
    letter = 'strong'
    if a in letter:
    	print('a는 letter의 철자로 존재합니다.')

    #수행 결과
    a는 letter의 철자로 존재합니다.
    ```

## 반복문(loop statement)

‘Hello World!’를 5번 반복 출력하는 프로그램이 필요하다고 합시다.

반복문을 사용하지 않고 구현하려면

```python
print('Hello World!')
print('Hello World!')
print('Hello World!')
print('Hello World!')
print('Hello World!')
```

가 되어야 합니다.

이 경우 반복 횟수가 적어서 큰 문제가 되지는 않지만, 만약 횟수가 크게 늘어난다면 같은 문장을 많은 줄에 걸쳐 적어야 하므로 매우 비효율적일 것

⇒ 반복문이 필요한 이유!

### **1. for 반복문**

for 반복문은 기본적으로 다음과 같은 형식입니다.

`for (변수) in (반복 가능한 객체) :`

`(수행할 문장1)`

`(수행할 문장2)`

`…`

in 뒤에 오는 ‘반복 가능한 객체(iterable)’은 list, tuple, 문자열 등을 말합니다.

```python
#예시
values = [10, 20, 30, 40, 50]
for a in values: #values에 존재하는 요소의 개수만큼 for문을 반복
	print(a)

#수행 결과
10
20
30
40
50
```

그럼 for을 사용할 때마다 계속 원하는 값들을 list로 만들어 선언해줘야 하나요?

⇒ 너무 번거로우므로,, **range()** 함수를 사용

range() 함수는 말 그대로 ‘정수로 이루어진 범위’를 만들 때 사용하는 함수입니다.

기본 형식은 range(시작값, 종료값, 증가량)입니다.

시작값의 기본값은 0, 증가량의 기본값은 1입니다.

```python
#예시
for a in range(0,6,2): #a가 0부터 2씩 증가해 6이 되는 순간 for문을 종료 => 3회 반복
	print(a, end=' ')

print('\n')
for b in range(1,4): #b가 1부터 1씩 증가해 4가 되는 순간 for문을 종료 => 3회 반복
	print(b, end=' ')

print('\n')
for c in range(5): #c가 0부터 1씩 증가해 5가 되는 순간 for문을 종료 => 5회 반
	print(c, end=' ')

#수행 결과
0 2 4 #range(0,6,2)

1 2 3 #range(1,4)

0 1 2 3 4 #range(5)
```

위 예시를 통해

range() 함수에 3개의 값을 모두 넣어주면 각각 시작값, 종료값, 증가량으로 사용됨

2개의 값을 넣어주면 각각 시작값과 종료값으로 사용, 증가량은 기본값 1로 적용됨

1개의 값만 넣어주면 종료값으로 사용, 시작값과 증가량은 각각의 기본값인 0과 1로 적용됨을 확인할 수 있습니다.

또한 range(A,B)의 범위는 A 이상 B 미만이므로 반복문에 사용 시 구간 설정에 유의해야 합니다.

간단한 예제를 통해 for ~ in range 구문을 이해하고 넘어갑시다.

```python
#예시
a='안녕하세요'
b='즐거운 추석 보내세요'

for k in range(6): #k가 0부터 1씩 증가해 6이 되는 순간 for문을 종료 => 6회 반복
	if k<3: #k가 3미만이면 a를 출력
		print(a)
	else: #k가 3이상이면 b를 출력
		print(b)

#수행 결과
안녕하세요 #k=0
안녕하세요 #k=1
안녕하세요 #k=2
즐거운 추석 보내세요 #k=3
즐거운 추석 보내세요 #k=4
즐거운 추석 보내세요 #k=5
```

### **2. while 반복문**

while문은 기본적으로 다음과 같은 형식입니다.

`while (조건식) :`

`(수행할 문장1)`

`(수행할 문장2)`

`…`

while은 조건식의 반환값이 True일 때만 반복문을 수행합니다.

조건이 거짓이 되면 반복문 수행을 종료하는데, 갑자기 종료하는 것이 아니라 ‘조건을 검사했을 때’ False이면 종료하는 방식입니다.

일반적으로 수행할 문장(블록) 안에 조건 결과를 변경시키는 코드가 들어갑니다.

```python
#예시
num=0
while num < 10 : #num<10이 참일 때 아래 블록을 수행
	num += 1 #num=num+1
	print(num, end=' ') #현재 num이 저장하고 있는 값을 출력

print('while문 종료')

#수행 결과
1 2 3 4 5 6 7 8 9 10
while문 종료
```

num=10이 되어 num<10의 반환값이 False가 되어도 while문의 하위 블록이 실행되고 있는 상태이므로 아래 문장인 print(num, end=’ ‘)를 수행합니다.

이후 다시 조건문으로 돌아와 검사했을 때, False이므로 while문을 벗어나 print(’while문 종료’)가 수행된 것을 볼 수 있습니다.

**‘while문의 하위 블록 진행 도중에 종료 조건이 성립되어도, 반복문이 자신의 조건을 검사할 차례가 될 때까지는 블록을 실행한다.’** 라는 것을 알아두시면 되겠습니다.

그렇다면 원할 때 바로 반복문을 종료하는 법은 없을까요?

### **3. break, continue**

break문을 사용하면 반복문을 즉시 종료할 수 있습니다.

```python
#예시
num=0
while num < 10 :
	num += 1
	if num == 5:
		print(num)
		break
	print(num, end=' ')

print('break로 인한 while문 종료')

#수행 결과
1 2 3 4 5
break로 인한 while문 종료
```

num에 5가 저장되면 해당 값을 print하고, break문이 수행되어 while문을 벗어나 반복문 밖의 문장이 수행되는 것을 확인할 수 있습니다.

그럼 만약 반복은 하되, 특정 부분은 처리하고 싶지 않을 때엔 어떻게 해야 할까요?

종료시킨 뒤 다시 반복문을 돌게 하면 너무 비효율적이고, break문은 아예 반복문을 탈출해버리니 사용하기 적절하지 않습니다.

이때 continue문을 사용하는데요, continue가 실행되면 해당 구문 이후 남은 하위 블록은 실행하지 않고 다시 처음(조건식)으로 되돌아가게 됩니다.

```python
#예시
num = 0
while num < 10:
	num += 1
	if num % 2 == 0:
		continue
	print(num, end=' ')

print('\nwhile문 종료')

#수행 결과
1 3 5 7 9
while문 종료
```

num % 2 == 0가 True면 continue문을 수행하게 되고, 이후 남은 부분인 print(num, end=’ ‘)를 수행하지 않고 while문의 조건식으로 돌아가게 됩니다.

그 결과 num이 짝수인 경우에는 print를 하지 않고 넘어가며, num이 10이 되는 순간 종료합니다.

for문에서도 break와 continue를 사용할 수 있습니다.

```python
#예시
for num in range(10):
    if num == 5:
        break
    print(num, end=' ')

print('\nbreak로 인한 for문 종료')

#수행 결과
0 1 2 3 4
break로 인한 for문 종료
```

num에 5가 저장되면 break를 통해 for문을 벗어나는 것을 확인할 수 있습니다.

```python
#예시
for num in range(10):
    if num % 2 == 0:
        continue
    print(num, end=' ')

print('\nfor문 종료')

#수행 결과
1 3 5 7 9
for문 종료
```

num에 짝수가 저장되면 continue를 통해 for문의 처음(조건식)으로 돌아가 홀수만 출력되는 것을 확인할 수 있습니다.

-   w**hile문에서 무한루프에 대해 간단하게 짚고 넘어갑시다!(펼쳐주세요)**
    while문에서는 무한루프가 발생할 수 있습니다.

    ```python
    #예시
    a = 2
    while a % 2 == 0:
    	a = a * 3 #a값이 항상 2*3^n의 꼴이 되므로 조건식을 만족한다.
    ```

    위 코드의 경우 a의 초기값이 2이고 조건식이 a%2==0인데 while문 내의 식이 a=a\*3이므로 항상 True가 되어 무한루프가 발생하게 됩니다.
    의도되지 않은 무한루프가 생기지 않게 조심해야겠죠?
    별개로, 일부러 무한루프를 만들고자 할 때엔 아래와 같이 코드를 작성합니다.

    ```python
    #예시
    while True:
    	print('언제 끝나노')

    #수행 결과
    ...
    언제 끝나노
    언제 끝나노
    언제 끝나노
    ...
    ```

    조건식 부분에 True를 적어주게 되면 무한루프를 만들 수 있습니다. 또는 정수 1처럼 True로 인식하는 값을 넣어주어도 됩니다.
    이런 무한루프를 빠져나올 때에도 break가 쓰이니 알아두시면 되겠습니다!
